
 
<%- row.start() %>

<%- column.start(4, 'padded') %>
<%- column.end() %>

<%- column.start(4, 'padded') %>

     <div class='inner-well' >
     <div class='canvas-3' id='showbox' style='width: 100%; height: 400px'></div>
         
   </div>
<%- column.end() %>

<%- column.start(4, 'padded') %>
<%- column.end() %>

<%- row.end() %>
 
<script>
    
    // after the document is loaded, run this function
    $(document).ready( function() {

        var div = $('#showbox');

        var container = document.getElementById( 'showbox' );
 
        // create the animation scene, camera, and renderer
        var scene = new THREE.Scene();
        var camera = new THREE.PerspectiveCamera( 75, div.width() / div.height(), 0.1, 1000 );
        renderer = new THREE.WebGLRenderer();

        // size the rendering to fit in the container div
        renderer.setSize( div.width(), div.height() );
        div.append( renderer.domElement );

        var toplight = new THREE.DirectionalLight( 0xffffff );
        var bottomlight = new THREE.DirectionalLight( 0xffffff );
        toplight.position.set( 0, 1, 1 ).normalize();
        bottomlight.position.set( 0, 0, 1 ).normalize();
        scene.add(toplight);
        scene.add(bottomlight);

        // create the object that will be animated
        var geometry = new THREE.BoxGeometry( 9.58, 0.1, 6 );
        //var material = new THREE.MeshBasicMaterial( { color: 0x00ff00 } );

        var materialbottom = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture('/images/bottom2.png') } );

        var materialtop = new THREE.MeshPhongMaterial( { map: THREE.ImageUtils.loadTexture('/images/top2.png') } );

        var materialsides = new THREE.MeshPhongMaterial( { ambient: 0x050505, color: 0x006000, specular: 0x555555, shininess: 30 } );
    
         var materials = [materialsides, materialsides, materialbottom, materialtop, materialsides, materialsides];
 
         var meshFaceMaterial = new THREE.MeshFaceMaterial( materials );

        var cube = new THREE.Mesh( geometry, meshFaceMaterial );
        scene.add( cube );

        // put the camera where you want it
        camera.position.z = 15;

        var PI = 3.1415926;

        // this is the rendering loop that actually moves the object
        var render = function () {
            requestAnimationFrame( render );

            // cube.rotation.y += 0.01;
            // cube.rotation.x += 0.01;
            // cube.rotation.x = PI/2;

            renderer.render(scene, camera);
        };

        var controls = new THREE.TrackballControls( camera );

        controls.rotateSpeed = 5.0;
        controls.zoomSpeed = 1.2;
        controls.panSpeed = 0.8;

        controls.noZoom = false;
        controls.noPan = false;

        controls.staticMoving = true;
        controls.dynamicDampingFactor = 0.3;

        controls.keys = [ 65, 83, 68 ];

        controls.addEventListener( 'change', render );


        // start rendering using the rendering loop defined above
        render();    
        requestAnimationFrame( animate );

        function animate() {
            requestAnimationFrame( animate );
            controls.update();
        }

        animate();
    });
               




//------------------------------------------------------------------------------------------------------
/*

if ( ! Detector.webgl ) Detector.addGetWebGLMessage();

var container, stats;

var camera, controls, scene, renderer;

var cross;

init();
animate();

function init() {

camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 1000 );
camera.position.z = 500;

controls = new THREE.TrackballControls( camera );

controls.rotateSpeed = 1.0;
controls.zoomSpeed = 1.2;
controls.panSpeed = 0.8;

controls.noZoom = false;
controls.noPan = false;

controls.staticMoving = true;
controls.dynamicDampingFactor = 0.3;

controls.keys = [ 65, 83, 68 ];

controls.addEventListener( 'change', render );

// world

scene = new THREE.Scene();
scene.fog = new THREE.FogExp2( 0xcccccc, 0.002 );

var geometry = new THREE.CylinderGeometry( 0, 10, 30, 4, 1 );
var material =  new THREE.MeshLambertMaterial( { color:0xffffff, shading: THREE.FlatShading } );

for ( var i = 0; i < 500; i ++ ) {

var mesh = new THREE.Mesh( geometry, material );
mesh.position.x = ( Math.random() - 0.5 ) * 1000;
mesh.position.y = ( Math.random() - 0.5 ) * 1000;
mesh.position.z = ( Math.random() - 0.5 ) * 1000;
mesh.updateMatrix();
mesh.matrixAutoUpdate = false;
scene.add( mesh );

}


// lights

light = new THREE.DirectionalLight( 0xffffff );
light.position.set( 1, 1, 1 );
scene.add( light );

light = new THREE.DirectionalLight( 0x002288 );
light.position.set( -1, -1, -1 );
scene.add( light );

light = new THREE.AmbientLight( 0x222222 );
scene.add( light );


// renderer

renderer = new THREE.WebGLRenderer( { antialias: false } );
renderer.setClearColor( scene.fog.color );
renderer.setPixelRatio( window.devicePixelRatio );
renderer.setSize( window.innerWidth, window.innerHeight );

container = document.getElementById( 'container' );
container.appendChild( renderer.domElement );

stats = new Stats();
stats.domElement.style.position = 'absolute';
stats.domElement.style.top = '0px';
stats.domElement.style.zIndex = 100;
container.appendChild( stats.domElement );

//

window.addEventListener( 'resize', onWindowResize, false );

//

render();

}

function onWindowResize() {

camera.aspect = window.innerWidth / window.innerHeight;
camera.updateProjectionMatrix();

renderer.setSize( window.innerWidth, window.innerHeight );

controls.handleResize();

render();

}

function animate() {

requestAnimationFrame( animate );
controls.update();

}

function render() {

renderer.render( scene, camera );
stats.update();

}

*/

</script>
 